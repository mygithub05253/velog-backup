# [Part 4] 객체 지향 설계와 스프링의 만남

**Published:** Wed, 14 Jan 2026 07:36:00 GMT
**Link:** https://velog.io/@kik328288/Part-4-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EB%A7%8C%EB%82%A8

---

<h3 id="1-스프링은-다형성--ocp-dip를-가능하게-하는-마법사">1. 스프링은 '다형성 + OCP, DIP'를 가능하게 하는 마법사</h3>
<hr />
<p>스프링은 다형성만으로는 해결할 수 없었던 OCP, DIP 문제를 해결하기 위해 다음과 같은 핵심 기술을 제공합니다.</p>
<ol>
<li><strong>DI (Dependency Injection):</strong> 의존관계 주입.</li>
<li><strong>DI 컨테이너:</strong> 객체 생성과 의존관계 연결을 대신 관리해 주는 컨테이너.</li>
</ol>
<p><strong>스프링의 효과:</strong></p>
<ul>
<li>이 기술들을 사용하면 <strong>클라이언트 코드의 변경 없이 기능을 확장</strong>할 수 있습니다.</li>
<li>우리가 원했던 <strong>&quot;부품을 교체하듯이 개발&quot;</strong>하는 것이 비로소 가능해집니다.</li>
<li>마치 레고 블럭을 조립하듯이, 공연 무대의 배우를 선택하듯이 구현을 편리하게 변경할 수 있게 됩니다.</li>
</ul>
<h3 id="2-스프링이-없던-시절의-개발-역사의-교훈">2. 스프링이 없던 시절의 개발 (역사의 교훈)</h3>
<hr />
<p>스프링이 없던 시절, 어떤 개발자가 &quot;나는 좋은 객체 지향 개발을 위해 OCP, DIP를 철저히 지킬 거야!&quot;라고 다짐했다고 가정해 봅시다.</p>
<ul>
<li>순수 자바 코드로 OCP, DIP를 지키기 위해 객체를 생성하고 연결해 주는 코드를 짜다 보니, <strong>할 일이 너무 많아집니다</strong>.</li>
<li>비즈니스 로직보다 프레임워크성 코드가 더 많아지는 <strong>&quot;배보다 배꼽이 더 큰&quot;</strong> 상황이 발생합니다.</li>
<li>결국 이 과정을 계속하다 보면, <strong>본인만의 프레임워크(DI 컨테이너)</strong>를 만들게 됩니다.</li>
</ul>
<p><strong>결론:</strong> 순수 자바로 좋은 객체 지향 원칙을 끝까지 추구하다 보면, <strong>필연적으로 스프링 프레임워크와 유사한 구조</strong>에 도달하게 됩니다. 스프링은 바로 이 고민을 해결해 주기 위해 만들어진 검증된 프레임워크입니다.</p>
<h3 id="3-실무-적용-가이드-역할과-구현을-분리하라">3. 실무 적용 가이드: 역할과 구현을 분리하라</h3>
<hr />
<p>스프링을 쓴다고 해서 저절로 좋은 설계가 나오는 것은 아닙니다. 개발자가 설계를 잘해야 합니다.</p>
<p>1) 이상적인 설계</p>
<ul>
<li><strong>모든 설계에 인터페이스(역할)를 부여</strong>하는 것이 가장 이상적입니다.</li>
<li>애플리케이션 설계를 공연 설계하듯이 배역(인터페이스)만 만들어두고, 배우(구현체)는 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋습니다.</li>
</ul>
<p>2) 현실적인 고민과 타협 (추상화 비용)</p>
<p>하지만 무작정 인터페이스를 도입하는 것이 정답은 아닙니다.</p>
<ul>
<li><strong>추상화 비용:</strong> 인터페이스를 도입하면 개발자가 코드를 한 번 더 열어봐야 하는(구현체가 뭔지 찾아야 하는) 비용이 발생합니다.</li>
<li><strong>실무 팁:</strong> 기능을 확장할 가능성이 없다면, 굳이 인터페이스를 만들지 말고 <strong>구체 클래스를 직접 사용</strong>하세요. 나중에 꼭 필요할 때 리팩터링을 통해 인터페이스를 도입하는 것도 좋은 방법입니다.</li>
</ul>