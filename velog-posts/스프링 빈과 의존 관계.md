# 스프링 빈과 의존 관계

**Published:** Mon, 05 Jan 2026 09:26:28 GMT
**Link:** https://velog.io/@kik328288/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%88%EA%B3%BC-%EC%9D%98%EC%A1%B4-%EA%B4%80%EA%B3%84

---

<h2 id="8-스프링-빈과-의존-관계">8. 스프링 빈과 의존 관계</h2>
<hr />
<p>스프링 부트 애플리케이션에서 객체(Bean)를 관리하고, 객체 간의 의존관계를 맺어주는 방법에는 크게 <strong>1) 컴포넌트 스캔과 자동 의존관계 설정</strong>과 <strong>2) 자바 코드로 직접 스프링 빈 등록하기</strong> 두 가지가 있다.</p>
<h3 id="8-1-컴포넌트-스캔과-자동-의존-관계-설정">8-1. 컴포넌트 스캔과 자동 의존 관계 설정</h3>
<hr />
<p>스프링이 기동될 때 특정 애노테이션이 붙은 클래스를 찾아 자동으로 스프링 빈(Bean)으로 등록하고, 의존관계를 연결해주는 방식이다.</p>
<p><strong>#### 8-1-1. 의존 관계 주입 (DI, Dependency Injection)</strong></p>
<ul>
<li><strong>개념:</strong> 객체 의존관계를 개발자가 코드에서 직접 <code>new</code> 연산자로 생성하여 넣어주는 것이 아니라, 외부(스프링 컨테이너)에서 생성하여 넣어주는 방식이다.</li>
<li><strong><code>@Autowired</code>:</strong> 생성자에 이 애노테이션이 있으면 스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 넣어준다.</li>
</ul>
<p><strong>#### 8-1-2. 컴포넌트 스캔 원리</strong></p>
<ul>
<li><strong><code>@Component</code>:</strong> 이 애노테이션이 붙은 클래스는 스프링 빈으로 자동 등록된다.</li>
<li><strong>스페셜티 애노테이션:</strong> 다음 애노테이션들은 내부에 <code>@Component</code>를 포함하고 있어 동일하게 스캔 대상이 된다 .<ul>
<li><code>@Controller</code>: 웹 MVC 컨트롤러 역할</li>
<li><code>@Service</code>: 핵심 비즈니스 로직 역할</li>
<li><code>@Repository</code>: 데이터베이스 접근 및 도메인 객체 관리 역할</li>
</ul>
</li>
</ul>
<p><strong>#### 8-1-3. 회원 관리 예제 코드 (Annotation 방식)</strong></p>
<ul>
<li>Controller</li>
</ul>
<pre><code class="language-java">@Controller
public class MemberController {
    private final MemberService memberService;

    @Autowired // 스프링 컨테이너에서 memberService를 찾아 주입
    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }
}</code></pre>
<ul>
<li>Service</li>
</ul>
<pre><code class="language-java">@Service // 스프링 빈으로 등록
public class MemberService {
    private final MemberRepository memberRepository;

    @Autowired // 생성자가 1개면 생략 가능
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}</code></pre>
<ul>
<li>Repository</li>
</ul>
<pre><code class="language-java">@Repository // 스프링 빈으로 등록
public interface MemberRepository {

    Member save(Member member);
    Optional&lt;Member&gt; findById(Long id);
    Optional&lt;Member&gt; findByName(String name);
    List&lt;Member&gt; findAll();

}</code></pre>
<p><strong>참고: 싱글톤(Singleton) 레지스트리</strong>
스프링은 컨테이너에 스프링 빈을 등록할 때, 기본적으로 <strong>유일하게 하나만 등록해서 공유</strong>하는 싱글톤 방식을 사용한다. 따라서 같은 스프링 빈을 주입받으면 모두 같은 인스턴스임이 보장된다.</p>
<h3 id="8-2-java-코드로-직접-스프링-빈-등록하기">8-2. Java 코드로 직접 스프링 빈 등록하기</h3>
<hr />
<p>컴포넌트 스캔(<code>@Service</code>, <code>@Repository</code> 등)을 사용하지 않고, 별도의 설정 클래스(<code>@Configuration</code>)를 만들어 직접 빈을 등록하는 방식이다.</p>
<p><strong>#### 8-2-1. 설정 방법</strong></p>
<ul>
<li>기존 클래스의 <code>@Service</code>, <code>@Repository</code>, <code>@Autowired</code> 애노테이션을 제거한다.</li>
<li><code>@Configuration</code> 애노테이션이 붙은 설정 클래스를 작성한다.</li>
<li><code>@Bean</code> 애노테이션을 메서드에 붙여 스프링 컨테이너에 빈을 등록한다.</li>
</ul>
<p><strong>#### 8-2-2. 예제 코드 (<code>SpringConfig.java</code>)</strong></p>
<pre><code class="language-java">package hello.hellospring;

import hello.hellospring.repository.MemberRepository;
import hello.hellospring.repository.MemoryMemberRepository;
import hello.hellospring.service.MemberService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SpringConfig {

    @Bean // 스프링 빈 등록
    public MemberService memberService() {
        // 의존관계 엮어주기 (생성자 주입)
        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository() {
        // 나중에 DB 리포지토리로 변경 시 이 부분만 수정하면 됨
        return new MemoryMemberRepository();
    }
}</code></pre>
<p><strong>#### 8-2-3. 사용하는 이유 (중요!)</strong></p>
<ul>
<li>정형화되지 않거나, <strong>상황에 따라 구현 클래스를 변경해야 하는 경우</strong>에 사용한다.</li>
<li><strong>예제 시나리오:</strong> 현재는 데이터 저장소가 선정되지 않아 <code>MemoryMemberRepository</code>를 쓰고 있지만, 향후 실제 DB 리포지토리로 교체할 예정이다. 이때 자바 코드로 설정을 해두면, <strong>다른 코드를 손대지 않고 <code>SpringConfig</code> 파일만 수정하여 구현체를 변경</strong>할 수 있다.</li>
</ul>
<h3 id="8-3-의존-관계-주입di의-3가지-방법과-권장-사항">8-3. 의존 관계 주입(DI)의 3가지 방법과 권장 사항</h3>
<hr />
<p>DI에는 필드 주입, setter 주입, 생성자 주입 3가지 방법이 있다.</p>
<p><strong>#### 8-3-1. DI 종류</strong></p>
<ul>
<li><strong>생성자 주입 (Constructor Injection):</strong><ul>
<li>생성자를 통해 의존관계를 주입받는 방법.</li>
<li><strong>권장:</strong> 의존관계가 실행 중에 동적으로 변하는 경우는 거의 없으므로, <strong>생성자 주입을 권장</strong>한다.</li>
</ul>
</li>
<li><strong>필드 주입 (Field Injection):</strong><ul>
<li><code>@Autowired private MemberService memberService;</code> 처럼 필드에 바로 주입하는 방법.</li>
<li>코드가 간결하지만 외부에서 변경이 불가능해 테스트하기 어렵다는 단점이 있어 권장하지 않는다.</li>
</ul>
</li>
<li><strong>Setter 주입 (Setter Injection):</strong><ul>
<li>setter 메서드에 <code>@Autowired</code>를 붙이는 방법.</li>
<li>메서드가 <code>public</code>으로 열려 있어야 하므로, 실행 중에 누군가 호출하여 의존관계가 바뀔 위험이 있다.</li>
</ul>
</li>
</ul>
<p><strong>#### 8-3-2. 실무 운영 팁</strong></p>
<ul>
<li><strong>정형화된 코드:</strong> 컨트롤러, 서비스, 리포지토리 같은 일반적인 코드는 <strong>컴포넌트 스캔</strong>을 사용하는 것이 편리하다.</li>
<li><strong>비정형화된 코드 / 변경 가능성:</strong> 구현 클래스를 변경해야 하는 상황(예: 리포지토리 변경)에서는 <strong>설정을 통해 스프링 빈으로 등록(자바 코드 방식)</strong>하는 것이 유지보수에 좋다.</li>
</ul>
<blockquote>
<p>주의사항@Autowired를 통한 DI는 HelloController, MemberService 등과 같이 <strong>스프링이 관리하는 객체(스프링 빈)</strong>에서만 동작한다. 스프링 빈으로 등록하지 않고 개발자가 직접 new로 생성한 객체에서는 동작하지 않는다 .</p>
</blockquote>