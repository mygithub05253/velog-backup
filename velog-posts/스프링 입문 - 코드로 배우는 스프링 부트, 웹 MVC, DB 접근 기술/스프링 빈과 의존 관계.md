# 스프링 빈과 의존 관계

**Published:** 2026-01-05T09:26:28.938Z
**Link:** https://velog.io/@kik328288/스프링-빈과-의존-관계

---

## 8. 스프링 빈과 의존 관계

---

스프링 부트 애플리케이션에서 객체(Bean)를 관리하고, 객체 간의 의존관계를 맺어주는 방법에는 크게 **1) 컴포넌트 스캔과 자동 의존관계 설정**과 **2) 자바 코드로 직접 스프링 빈 등록하기** 두 가지가 있다.

### 8-1. 컴포넌트 스캔과 자동 의존 관계 설정

---

스프링이 기동될 때 특정 애노테이션이 붙은 클래스를 찾아 자동으로 스프링 빈(Bean)으로 등록하고, 의존관계를 연결해주는 방식이다.

**#### 8-1-1. 의존 관계 주입 (DI, Dependency Injection)**

- **개념:** 객체 의존관계를 개발자가 코드에서 직접 `new` 연산자로 생성하여 넣어주는 것이 아니라, 외부(스프링 컨테이너)에서 생성하여 넣어주는 방식이다.
- **`@Autowired`:** 생성자에 이 애노테이션이 있으면 스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 넣어준다.

**#### 8-1-2. 컴포넌트 스캔 원리**

- **`@Component`:** 이 애노테이션이 붙은 클래스는 스프링 빈으로 자동 등록된다.
- **스페셜티 애노테이션:** 다음 애노테이션들은 내부에 `@Component`를 포함하고 있어 동일하게 스캔 대상이 된다 .
    - `@Controller`: 웹 MVC 컨트롤러 역할
    - `@Service`: 핵심 비즈니스 로직 역할
    - `@Repository`: 데이터베이스 접근 및 도메인 객체 관리 역할

**#### 8-1-3. 회원 관리 예제 코드 (Annotation 방식)**

- Controller

```java
@Controller
public class MemberController {
    private final MemberService memberService;

    @Autowired // 스프링 컨테이너에서 memberService를 찾아 주입
    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }
}
```

- Service

```java
@Service // 스프링 빈으로 등록
public class MemberService {
    private final MemberRepository memberRepository;

    @Autowired // 생성자가 1개면 생략 가능
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```

- Repository

```java
@Repository // 스프링 빈으로 등록
public interface MemberRepository {

    Member save(Member member);
    Optional<Member> findById(Long id);
    Optional<Member> findByName(String name);
    List<Member> findAll();

}
```

**참고: 싱글톤(Singleton) 레지스트리**
스프링은 컨테이너에 스프링 빈을 등록할 때, 기본적으로 **유일하게 하나만 등록해서 공유**하는 싱글톤 방식을 사용한다. 따라서 같은 스프링 빈을 주입받으면 모두 같은 인스턴스임이 보장된다.

### 8-2. Java 코드로 직접 스프링 빈 등록하기

---

컴포넌트 스캔(`@Service`, `@Repository` 등)을 사용하지 않고, 별도의 설정 클래스(`@Configuration`)를 만들어 직접 빈을 등록하는 방식이다.

**#### 8-2-1. 설정 방법**

- 기존 클래스의 `@Service`, `@Repository`, `@Autowired` 애노테이션을 제거한다.
- `@Configuration` 애노테이션이 붙은 설정 클래스를 작성한다.
- `@Bean` 애노테이션을 메서드에 붙여 스프링 컨테이너에 빈을 등록한다.

**#### 8-2-2. 예제 코드 (`SpringConfig.java`)**

```java
package hello.hellospring;

import hello.hellospring.repository.MemberRepository;
import hello.hellospring.repository.MemoryMemberRepository;
import hello.hellospring.service.MemberService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SpringConfig {

    @Bean // 스프링 빈 등록
    public MemberService memberService() {
        // 의존관계 엮어주기 (생성자 주입)
        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository() {
        // 나중에 DB 리포지토리로 변경 시 이 부분만 수정하면 됨
        return new MemoryMemberRepository();
    }
}
```

**#### 8-2-3. 사용하는 이유 (중요!)**

- 정형화되지 않거나, **상황에 따라 구현 클래스를 변경해야 하는 경우**에 사용한다.
- **예제 시나리오:** 현재는 데이터 저장소가 선정되지 않아 `MemoryMemberRepository`를 쓰고 있지만, 향후 실제 DB 리포지토리로 교체할 예정이다. 이때 자바 코드로 설정을 해두면, **다른 코드를 손대지 않고 `SpringConfig` 파일만 수정하여 구현체를 변경**할 수 있다.

### 8-3. 의존 관계 주입(DI)의 3가지 방법과 권장 사항

---

DI에는 필드 주입, setter 주입, 생성자 주입 3가지 방법이 있다.

**#### 8-3-1. DI 종류**

- **생성자 주입 (Constructor Injection):**
    - 생성자를 통해 의존관계를 주입받는 방법.
    - **권장:** 의존관계가 실행 중에 동적으로 변하는 경우는 거의 없으므로, **생성자 주입을 권장**한다.
- **필드 주입 (Field Injection):**
    - `@Autowired private MemberService memberService;` 처럼 필드에 바로 주입하는 방법.
    - 코드가 간결하지만 외부에서 변경이 불가능해 테스트하기 어렵다는 단점이 있어 권장하지 않는다.
- **Setter 주입 (Setter Injection):**
    - setter 메서드에 `@Autowired`를 붙이는 방법.
    - 메서드가 `public`으로 열려 있어야 하므로, 실행 중에 누군가 호출하여 의존관계가 바뀔 위험이 있다.

**#### 8-3-2. 실무 운영 팁**

- **정형화된 코드:** 컨트롤러, 서비스, 리포지토리 같은 일반적인 코드는 **컴포넌트 스캔**을 사용하는 것이 편리하다.
- **비정형화된 코드 / 변경 가능성:** 구현 클래스를 변경해야 하는 상황(예: 리포지토리 변경)에서는 **설정을 통해 스프링 빈으로 등록(자바 코드 방식)**하는 것이 유지보수에 좋다.

> 주의사항@Autowired를 통한 DI는 HelloController, MemberService 등과 같이 **스프링이 관리하는 객체(스프링 빈)**에서만 동작한다. 스프링 빈으로 등록하지 않고 개발자가 직접 new로 생성한 객체에서는 동작하지 않는다 .


