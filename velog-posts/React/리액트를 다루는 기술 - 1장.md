# 리액트를 다루는 기술 - 1장

**Published:** 2025-09-26T05:22:16.382Z
**Link:** https://velog.io/@kik328288/리액트를-다루는-기술-1장

---

## 1장 리액트 시작
### 1.1 왜 리액트인가?
1. 자바스크립트 인식 변화
- 과거 : 웹 브라우저에서 간단한 연산을 하거나 시각적인 효과를 주는 단순한 스크립트 언어
- 현재 : 웹 애플리케이션에서 가장 핵심적인 역할
2. 자바스크립트 기반 프레임워크
![](https://velog.velcdn.com/images/kik328288/post/9b4d4e46-9407-4d7e-ae25-d6f72bd7cb93/image.png)
- 해당 프레임워크들은 주로 MVC(Model-View-Controller) 아키텍처, MVVM(Model-View-View Model) 아키텍처 사용
- AngularJS의 경우 MVW(Model-View-Whatever) 아키텍처로 애플리케이션 구조화

- MVC, MVVM, MVW 등 여러 구조가 지닌 공통점 : 모델(Model), 뷰(View) 보유
  - 모델(Model) : 애플리케이션에서 사용하는 데이터를 관리하는 영역
  - 뷰(View) : 사용자에게 보이는 부분
  - 프로그램이 사용자에게서 어떤 작업을 받으면 컨트롤러는 모델 데이터를 조회하거나 수정하고, 변경된 사항을 뷰에 반영
  ![](https://velog.velcdn.com/images/kik328288/post/de04fa15-cfbd-4057-88d0-ab46c942feb4/image.png)
  - 반영하는 과정에서 보통 뷰를 변형
- 업데이트하는 항목에 따라 어떤 부분을 찾아서 변경할 지 규칙을 정하는 작업은 간단하지만, 애플리케이션 규모가 크면 상당히 복잡해지고 제대로 관리하지 않으면 성능 감소 가능성 존재
  - 어떤 데이터가 변할 때마다 어떤 변화를 줄 지 고민하는 것이 아니라 그냥 기존 뷰를 날려버리고 처음부터 새로 렌더링하는 방식으로 해결
    - 애플리케이션 구조가 매우 간단해짐
    - 작성해야 할 코드의 양 역시 감소
    - 더 이상 어떻게 변화를 줄 지 신경 쓸 필요 없음
    - 뷰가 어떻게 생길 지 선언하며, 데이터에 변화가 있음녀 기존에 있던 것을 버리고 정해진 규칙에 따라 새로 렌더링하면 해결됨
- 이러한 것들을 해결하고 동작하는 것이 바로 리액트(React)
---
#### 1.1.1 리액트 이해

- 리액트(React)
  - 자바스크립트 라이브러리
  - 사용자 인터페이스를 만드는 데 사용되는 프레임워크
  - 구조가 MVC, MVW 등인 프레임워크와 달리 오직 V(View)만 신경 쓰는 라이브러리
- 컴포넌트(Component)
  - React 프로젝트에서 특정 부분이 어떻게 생길지 정하는 선언체
  - 다른 프레임워크에서 사용자 인터페이스를 다룰 때 사용하는 템플릿과는 다른 개념
  - 재사용이 가능한 API => 수많은 기능들을 내장
  - 컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식 정의
  - 컴포넌트 내부에는 또 다른 컴포넌트가 들어가는 것 가능
- 템플릿
    - 데이터셋이 주어지면 HTML 태그 형식을 문자열로 반환
- 렌더링
  - 사용자 화면에 뷰를 보여주는 것
##### 1.1.1.1 초기 렌더링
어떤 UI 관련 프레임워크, 라이브러리를 사용하든지 간에 맨 처음 어떻게 보일 지를 정하는 초기 렌더링 필요
- render() 함수
  - 사용 형식 : render() { ... }
  - 컴포넌트가 어떻게 생겼는 지 정의하는 역할
  - html 형식의 문자열을 반환하지 않고, 뷰가 어떻게 생겼고 어떻게 작동하는 지에 대한 정보를 지닌 객체 반환
  - render 함수를 실행하면 그 내부에 있는 컴포넌트들도 재귀적으로 렌더링
- 최상위 컴포넌트의 렌더링 작업이 끝나면 지니고 있는 정보들을 사용해 HTML 마크업을 만들고, 이를 우리가 정하는 실제 페이지의 DOM 요소 안에 주입
![](https://velog.velcdn.com/images/kik328288/post/ff9f5f57-4546-4f79-87e5-a30c1e03bfbf/image.png)
- 컴포넌트를 실제 페이지에 렌더링할 때는 분리된 두 가지 절차를 따름
  1. 문자열 형태의 HTML 코드 생성
  2. 특정 DOM에 해당 내용을 주입
  3. 이벤트 적용
##### 1.1.1.2 조화 과정
render 함수의 추가적인 역할
- 뷰가 어떻게 생겼고 어떻게 작동하는 지에 대한 정보를 지닌 객체 반환
- 컴포넌트는 데이터를 업데이트했을 때 단순히 업데이트한 값을 수정하는 것이 아니라, 새로운 데이터를 가지고 render 함수를 다시 호출하는 것
- render 함수가 반환하는 결과를 바로 DOM에 반영하지 않고 이전에 render 함수가 만들었던 컴포넌트 정보와 현재 render 함수가 만든 컴포넌트 정보 비교
![](https://velog.velcdn.com/images/kik328288/post/bc925a1f-d494-415b-bcd6-482e63af9fa8/image.png)
- 자바스크립트를 사용해 두 가지 뷰를 최소한의 연산으로 비교한 후, 둘의 차이를 알아내 최소한의 연산으로 DOM 트리를 업데이트 하는 것
![](https://velog.velcdn.com/images/kik328288/post/e4afb053-6450-4b41-950a-d120aae63377/image.png)
- 결론 : 방식 자체는 루트 노드부터 시작하여 전체 컴포넌트를 처음부터 다시 렌더링하는 것처럼 보이지만, 최적의 자원을 사용해 이를 수행하는 것
---
### 1.2 리액트의 특징
#### 1.2.1 Virtual DOM
리액트의 주요 특징 중 하나 : Virtual DOM 사용
##### 1.2.1.1 DOM이란?
- DOM (Document Object Model)
  - XML, HTML 등을 이용해 객체로 문서 구조를 표현하는 방법
  - 트리 형태이기 때문에 특정 노드를 찾거나 수정하거나 제거하거나 원하는 곳에 삽입 가능
  ![](https://velog.velcdn.com/images/kik328288/post/e5a93604-ce89-42e7-b96b-c27f860a0ab0/image.png)

- DOM의 속도
  - DOM API를 수많은 플랫폼과 웹 브라우저에서 사용 중
  - DOM의 문제점
    - 동적 UI에 최적화되어 있지 않다는 것
    - HTML이 자체적으로 정적이지만 자바스크립트를 사용해 동적으로 만들 수 있기 때문
  - 규모가 큰 웹 애플리케이션에서 DOM에 직접 접근하여 변화를 주게 될 경우 성능 이슈가 조금 발생해 속도가 느려짐
  - DOM 자체의 속도는 빠른 편
    - DOM 자체를 읽고 쓸 때의 성능은 자바스크립트 객체를 처리할 때의 성능과 비교해 별 차이가 없음
    - 웹 브라우저 단에서 DOM에 변화가 일어날 경우 웹 브라우저가 CSS를 다시 연산하고, 레이아웃을 구성하고, 페이지를 리페인트하기 때문에 시간이 더 걸리는 것
- DOM의 속도 저하 문제 해결 방법 : 리액트에서 Virtual DOM 방식을 활용해 DOM 업데이트를 추상화함으로써 DOM 처리 횟수를 최소화하고 효율적으로 진행
##### 1.2.1.2 Virtual DOM
Virtual DOM 사용할 경우 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용
실제 DOM의 가벼운 사본과 비슷하다고 생각하면 됨
리액트에서데이터가 변하여 웹 브라우저에 실제 DOM을 업데이트 할 때 절차
1. 데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링
2. 이전 Virtual DOM에 있던 내용과 현재 내용 비교
3. 바뀐 부분만 실제 DOM에 적용
![](https://velog.velcdn.com/images/kik328288/post/bc925a1f-d494-415b-bcd6-482e63af9fa8/image.png)
- 리액트와 Virtual DOM이 언제나 제공할 수 있는 것 : 업데이트 처리 간결성
  - UI를 업데이트하는 과정에서 생기는 복잡함을 모두 해소
  - 더욱 쉽게 업데이트에 접근 가능
#### 1.2.2 기타 특징
- 리액트의 경우 MVC 또는 MVW 등의 구조를 지향하는 것과 달리 오직 뷰만 담당
- 리액트는 프레임워크가 아니라 라이브러리이므로 기타 기능은 직접 구현하여 사용해야 함
- 라우팅에는 react-router, Ajax 처리에는 axios나 fetch, 상태 관리에는 redix나 MobX를 사용
- 해당 분야에서 마음에 드는 라이브러리를 사용하면 되서 자신의 취향대로 스택을 설정할 수 있다는 장점
- 여러 라이브러리를 접해야 한다는 단점
![](https://velog.velcdn.com/images/kik328288/post/ff0beda5-53ad-4da4-bd59-586b8209a843/image.png)
- 리액트는 다른 웹 프레임워크나 라이브러리와 혼용 가능
![](https://velog.velcdn.com/images/kik328288/post/c0653a77-1f30-43bc-b773-76b00cb17626/image.png)
### 1.3 React 프로젝트 생성
#### 1.3.1 🚀 CRA (Create React App) 정말 지원 중단됐을까? (feat. 앞으로의 React 프로젝트 설정)

안녕하세요! React를 처음 배울 때 가장 먼저 만나는 친구 같은 존재, `create-react-app`에 대한 이야기를 해보려고 합니다. 최근 CRA가 지원 중단되었다, 혹은 deprecated 되었다는 이야기를 많이 들어보셨을 텐데요. 그런데 막상 터미널에 `npx create-react-app my-app`을 입력하면 아무 문제 없이 프로젝트가 생성되는 것을 보고 혼란스러우셨을 겁니다.

결론부터 말씀드리면, **CRA는 공식적으로 새로운 기능 업데이트가 중단된 것이 맞지만, 완전히 사용 불가능한 상태는 아닙니다.** 이 글에서는 CRA의 현재 상태는 어떤지, 왜 여전히 작동하는지, 그리고 앞으로 우리는 어떤 도구를 사용해야 할지에 대해 자세히 알아보겠습니다.

##### 1.3.1.1 CRA, 정확히 어떤 상태인가요?

React 공식 문서(react.dev)의 [Start a New React Project](https://react.dev/learn/start-a-new-react-project) 페이지에 방문하면 더 이상 CRA를 기본 도구로 추천하지 않는 것을 확인할 수 있습니다.

> **"If you’re looking to create a new app or a new site with React, we recommend picking one of the production-grade React frameworks."**
> (React로 새로운 앱이나 사이트를 만들고 싶다면, 프로덕션 등급의 React 프레임워크 중 하나를 선택하는 것을 추천합니다.)

과거에는 CRA가 React 학습의 표준 시작점이었지만, 지금은 **Next.js, Remix, Gatsby** 같은 프레임워크나 **Vite, Parcel**과 같은 차세대 빌드 도구를 권장하고 있습니다.

CRA의 GitHub 저장소를 보아도 2023년 이후로는 큰 업데이트가 거의 없는 '유지보수 모드(maintenance mode)'에 가깝습니다. 이는 새로운 기능 추가나 대대적인 개선은 없지만, 심각한 보안 취약점이 발견되면 패치를 제공하는 수준이라고 이해할 수 있습니다.

##### 1.3.1.2 그런데 왜 여전히 작동할까요?

CRA가 지원 중단되었다고 해서 npm 레지스트리에서 패키지가 삭제되는 것은 아닙니다. `npx create-react-app` 명령어는 여전히 npm에 등록된 마지막 버전의 CRA 패키지를 다운로드하여 프로젝트를 생성합니다. 따라서 기존 방식대로 프로젝트를 만드는 것 자체는 가능합니다.

하지만 여기에는 몇 가지 문제점이 있습니다.

- **느린 개발 서버 속도**: CRA는 내부적으로 Webpack을 사용합니다. Vite와 같은 최신 번들러는 ESBuild를 사용하여 훨씬 빠른 개발 서버 구동 속도와 Hot Module Replacement(HMR) 성능을 보여줍니다. 프로젝트 규모가 커질수록 이 차이는 크게 체감됩니다.
- **오래된 의존성**: 핵심 라이브러리들의 업데이트가 중단되어 최신 버전의 이점을 누리기 어렵고, 잠재적인 보안 위협에 노출될 수 있습니다.
- **확장성의 한계**: Babel, Webpack 설정을 직접 수정하려면 `eject` 명령어를 사용해야 하는데, 한번 실행하면 되돌릴 수 없고 모든 설정의 책임이 개발자에게 넘어와 복잡성이 크게 증가합니다.

##### 1.3.1.3 이제 우리는 무엇을 사용해야 할까요?

React 팀과 커뮤니티가 추천하는 현대적인 대안은 다음과 같습니다.

 ✅ **Vite: 가장 유력한 CRA 대체재**

![](https://velog.velcdn.com/images/kik328288/post/a6f1832b-b392-4f71-a911-557acf0b0f6f/image.png)
 만약 순수 React SPA(Single Page Application)를 만들고 싶고, CRA의 경험과 가장 유사하면서도 강력한 성능을 원한다면 **Vite**가 최고의 선택입니다.

- **압도적으로 빠른 속도**: ESBuild를 사용한 빠른 개발 서버와 빌드 속도를 자랑합니다.
- **간단한 설정**: CRA만큼이나 시작이 쉽고, 필요한 경우 `vite.config.js` 파일을 통해 손쉽게 설정을 확장할 수 있습니다.
- **활발한 생태계**: 수많은 플러그인과 커뮤니티 지원을 통해 개발 경험을 향상시킬 수 있습니다.

**Vite로 React 프로젝트 시작하기:**

```bash
# npm
npm create vite@latest my-react-app -- --template react

# yarn
yarn create vite my-react-app --template react

# pnpm
pnpm create vite my-react-app --template react
```
![](https://velog.velcdn.com/images/kik328288/post/bc60fc82-0096-4efb-9046-c588fb1ffe55/image.png)

---

##### 1.3.2 React 프로젝트 구조(with Vite)

---

```bash
├── README.md
├── index.html
├── package-lock.json
├── package.json
├── public
│   └── vite.svg
├── src
│   ├── App.css
│   ├── App.jsx
│   ├── assets
│   │   └── react.svg
│   ├── index.css
│   └── main.jsx
└── vite.config.js
```

이 디렉토리 구조는 Vite로 생성한 리액트 프로젝트의 기본 구조입니다. 각 파일과 폴더의 역할을 설명하겠습니다.

- [**`README.md`**](http://readme.md/) - 프로젝트에 대한 설명이나 문서를 담는 파일입니다.
- **`index.html`** - 리액트 애플리케이션의 진입점으로, 기본 HTML 파일입니다. 여기서 리액트 앱이 렌더링됩니다.
- **`package-lock.json`**: npm 패키지의 의존성 트리를 정확하게 재현하기 위한 파일입니다.
- **`package.json`**: 프로젝트의 메타데이터와 의존성 관리를 위한 파일입니다. 스크립트, 의존성 목록 등이 여기에 포함됩니다.
- **`public/`** - 정적 파일을 저장하는 디렉토리입니다. 이 디렉토리에 있는 파일들은 빌드 과정에서 그대로 복사됩니다.
- **`src/`**: 소스 코드를 저장하는 디렉토리입니다. 실제 리액트 컴포넌트들과 애플리케이션의 주요 코드가 이곳에 위치합니다.
    - **`App.css`**: 리액트 애플리케이션에서 사용되는 CSS 파일입니다.
    - **`App.jsx`**: 루트 컴포넌트인 App 컴포넌트가 정의되어 있는 파일입니다. 이 파일은 주로 렌더링할 컴포넌트들을 조합하는 역할을 합니다.
    - **`assets/`**: 이미지나 기타 정적 파일을 저장하는 디렉토리입니다.
        - **`react.svg`**: 예시로 제공된 리액트 관련 이미지 파일입니다.
    - **`index.css`**: index.html에 적용될 CSS 파일입니다.
    - **`main.jsx`**: 애플리케이션의 진입점이 되는 파일입니다. 리액트 앱을 브라우저에 렌더링하고, 필요한 리소스들을 불러오는 역할을 합니다.
- **`vite.config.js`**: Vite 빌드 시스템의 설정 파일입니다. Vite 플러그인 및 프로젝트 구성과 관련된 설정을 정의합니다.
- **public vs assets 차이점**
    
    `public` 디렉토리와 `assets` 디렉토리의 주요 차이점은 다음과 같습니다:
    
    1. **public 디렉토리**:
        - `public` 디렉토리는 정적 파일을 저장하는 곳입니다.
        - 이 디렉토리에 있는 파일들은 빌드 과정에서 그대로 복사되어 최종 번들에 포함됩니다.
        - 주로 HTML 파일, favicons, 이미지, 폰트 등의 파일을 저장합니다.
        - 이 디렉토리의 파일들은 빌드 과정에서 처리되지 않고 그대로 복사되므로, 파일 경로를 그대로 사용하여 로드할 수 있습니다.
    2. **assets 디렉토리**:
        - `assets` 디렉토리는 소스 코드에서 사용되는 정적 자원을 저장하는 곳입니다.
        - 이 디렉토리는 보통 이미지, 아이콘, 스타일시트 등의 리소스를 저장하는 용도로 사용됩니다.
        - `assets` 디렉토리에 있는 파일들은 소스 코드에서 import하여 사용하며, 빌드 과정에서 번들에 포함됩니다.
        - 예를 들어, 자바스크립트 파일에서 `import` 또는 `require`를 사용하여 이미지나 스타일시트 파일을 로드할 수 있습니다.
    
    요약하자면, `public` 디렉토리는 빌드 과정에서 처리되지 않고 그대로 복사되는 정적 파일들을 저장하는 곳이며, `assets` 디렉토리는 소스 코드에서 사용되는 정적 자원을 저장하는 곳입니다.

