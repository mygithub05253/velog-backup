# 리액트를 다루는 기술 - 2장

**Published:** 2025-09-30T05:56:15.288Z
**Link:** https://velog.io/@kik328288/리액트를-다루는-기술-2장

---

# 2장 JSX
## 2.1 App.jsx 코드 이해하기
### 2.1.1 `App.jsx` : Vite + React 프로젝트
Vite를 사용해 React 프로젝트를 처음 생성할 경우 생기는 파일이다.
해당 파일은 애플리케이션의 메인 화면을 구성하는 핵심 컴포넌트이다.

#### 2.1.1.1 Import 구문
컴포넌트 최상단에는 필요한 자바스크립트 모듈과 에셋(이미지, CSS)을 가져오는 `import` 구문이 존재한다

```jsx
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import './App.css'

```

1. `import { useState } from 'react'`
- React의 `usestate` Hook 가져오는 import 구문
- 해당 Hook은 함수형 컴포넌트에서 상태(state)를 관리할 수 있게 해주는 중요한 기능

2. `import reactLogo from './assets/react.svg'`
- `./assets/react.svg` : `./assets` 폴더에 있는 React 로고 SVG 파일을 `reactLogo`라는 이름으로 가져옴

3. `import viteLogo from '/vite.svg'`
- `public` 폴더에 있는 Vite 로고 SVG 파일을 `viteLogo`라는 이름으로 가져옴
- Vite는 `public` 디렉토리를 서버 루트로 취급하므로 `/vite.svg`와 같이 절대 경로로 참조 가능

4. `import './App.css'`
- 해당 컴포넌트에 적용될 CSS 스타일을 가져옴

---

#### 2.1.1.2 App 컴포넌트와 상태 관리
`App()` 함수 : 해당 애플리케이션의 메인 컴포넌트

```jsx
function App() {
  const [count, setCount] = useState(0)
  
  // JSX 반환 코드
  return (
    
  )
}  
```

- const [count, setCount] = useState(0) : `useState` Hook을 사용해서 `count`라는 이름의 상태 선언
  - `count` : 현재 상태 값을 저장하는 변수
  - `setCount`
    - `count` 상태를 변경할 수 있는 함수
    - 해당 함수를 호출해야만 React가 상태 변경을 감지하고 화면 리렌더링 수행

---

#### 2.1.1.3 화면을 그리는 JSX
컴포넌트는 `return` 문을 통해 화면에 표시될 UI 요소 반환하는 문법을 JSX(JavaScript SML)이라고 부름

```jsx
  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + React</h1>
      <div className="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
        <p>
          Edit <code>src/App.jsx</code> and save to test HMR
        </p>
      </div>
      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
```

1. `<></>` (Fragment)
- JSX는 반드시 하나의 부모 요소로 감싸져야 함
- 불필요한 `<div>` 태그를 만들지 않고 여러 요소를 묶기 위해 Fragment 사용

2. 로고 표시
- `<img>` 태그의 `src` 속성에 `import`로 가져온 `viteLogo`와 `reactLogo` 변수를 할당해 이미지를 표시
- JSX 내에서 자바스크립트 변수나 표현식을 사용하려면 중괄호({})로 감싸야 함

3. 버튼과 이벤트 핸들러
- `<button>` 요소의 `onClick` 속성에 함수를 연결해 클릭 이벤트 처리
- `() => setCount((count) => count + 1`
  - 버튼이 클릭될 때마다 `setCount` 함수를 호출해 `count` 상태를 1씩 증가
  - 함수형 업데이트를 사용할 경우, 이전 상태 값(state)을 기반으로 안전하게 다음 상태 계산 가능
- `count is {count}` : 중괄호를 사용해 현재 `count` 상태 값을 버튼 텍스트에 동적으로 표시

---

#### 2.1.1.4 컴포넌트 내보내기 (Export)
다른 파일에서 해당 `App` 컴포넌트를 가져다 쓸 수 있도록 해주는 과정

```jsx
export default App
```

- `export default`
  - 해당 파일의 기본 내보내기 대상으로 `App` 컴포넌트를 지정한다는 의미
  - 내보낸 컴포넌트는 `main.jsx` 파일에서 `import`해 실제 웹 페이지에 렌더링

---

## 2.2 JSX
JSX는 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생겼습니다.
이런 형식으로 작성한 코드는 브라우저에서 실행되기 전에 코드가 번들링되는 과정에서 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환됩니다.

### 2.2.1 JSX 코드 변환 과정
#### 2.2.1.1 JSX 변환의 핵심: `React.createElement()`
- 결론 : JSX 코드는 `React.createElement()`라는 JavaScript 함수 호출로 변환
간단한 JSX 예시
```jsx
const element = <h1>Hello, world!</h1>;
```

바벨이 `React.createElement()` 함수 호출로 변환한 코드
```jsx
const element = React.createElement(
  'h1',
  null,
  'Hello, world!'
);
```

#### 2.2.1.2 React.createElement()가 받는 인자
1. `type` 
- 태그의 유형
- h1, div 같은 HTML 태그 이름이 문자열로 전달되거나, 다른 리액트 컴포넌트가 오는 것 가능

2. `props` 
- 속성(어트리뷰트)
- JSX에 className이나 id 같은 props가 있었다면 이 인자는 {'className': 'greeting'}과 같은 객체 형태
- 위 예시처럼 props가 없으면 null이 전달

3. `children` 
- 자식 요소 
- 태그 사이에 오는 모든 자식 콘텐츠가 여기에 포함
- 텍스트일 수도 있고, 다른 React.createElement() 호출일 수도 있음

---

### 2.2.2 중첩된 요소의 변환 과정
JSX 요소가 중첩되면 `React.createElement()` 함수도 중첩된 구조로 변환
JSX 코드 예시
```jsx
const element = (
  <div className="greeting">
    <h1>Hello!</h1>
    <p>Nice to meet you.</p>
  </div>
);
```

변환된 JavaScript 코드
```javascript
const element = React.createElement(
  'div',
  { className: 'greeting' },
  React.createElement('h1', null, 'Hello!'),
  React.createElement('p', null, 'Nice to meet you.')
);
```
JSX는 개발자가 UI 구조를 직관적으로 작성할 수 있게 해주고, 실제로는 JavaScript 객체를 생성하는 `React.createElement()` 함수로 변환되어 React가 UI를 렌더링하는 데 사용

---

### 2.2.3 JSX의 장점
1. 보기 쉽고 익숙하다
2. 더욱 높은 활용도
JSX에서는 우리가 알고 있는 div나 span 같은 HTML 태그를 사용할 수 있을 뿐만 아니라, 컴포넌트 역시 JSX 안에서 작성 가능

---

### 2.2.4 JSX 문법
#### 2.2.4.1 감싸인 요소
컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 합니다.
요소 여러 개가 부모 요소 하나에 의해 감싸져 있지 않은 경우 오류가 발생합니다.
리액트 컴포넌트에서 요소 여러 개를 하나의 요소로 감싸줘야 하는 이유
- Virtual DOM에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙 때문

리액트 v16 이상부터 도입된 Fragment라는 기능을 사용해서 div 요소 등을 사용하지 않아도 되게 되었습니다.
```jsx
import { Fragment } from "react";

function App() {
  return(
    <Fragment>
      <h1>리액트 안녕!</h1>
    </Fragment>
  );
}

export default App;
```

코드 상단 import 구문에서 react 모듈에 들어 있는 Fragment라는 컴포넌트를 불러오는 방식으로 사용하는데 `<></>` 이런 방식으로 Fragment를 사용할 수도 있습니다.

다만 과거에는 JSX를 사용하는 모든 파일 상단에 `import React from 'react'`를 작성해야 했습니다. 하지만 최신 Vite + React 프로젝트에서는 이 코드가 자동으로 처리되므로 생략할 수 있습니다. 코드가 훨씬 간결해졌습니다.

```jsx
// src/App.jsx

// import React from 'react' // 이 라인이 없어도 잘 동작합니다!
import './App.css'

function App() {
  return (
    <h1>Hello, Vite + React!</h1>
  )
}

export default App
```

---

#### 2.2.4.2 JSX 기본 규칙
1. 모든 태그는 닫혀야 합니다.
HTML과 달리, JSX에서는 `<br>`이나 `<img>` 같은 단일 태그도 반드시 스스로 닫아야 합니다.
```jsx
// 잘못된 예
// <img src="profile.jpg">
// <br>

// 올바른 예
<img src="profile.jpg" />
<br />
```

2. 최상위 요소는 하나여야 합니다. (Fragments)
두 개 이상의 요소를 반환하려면, 보이지 않는 `Fragment`로 감싸야 합니다. `<div>`로 감싸도 되지만, 불필요한 태그 생성을 막기 위해 `Fragment` 사용이 권장됩니다.
```jsx
// 빈 꺽쇠(<>)가 바로 Fragment의 축약 문법입니다.
return (
  <>
    <h1>제목</h1>
    <p>내용입니다.</p>
  </>
)
```

3. JSX 안에서 JavaScript 표현식 사용하기
JSX 내에서 JavaScript 변수나 표현식을 사용하려면 중괄호 {}를 사용합니다.
```jsx
function Greeting({ name }) {
  const welcomeMessage = '님, 환영합니다!';
  
  return (
    <h1>{name}{welcomeMessage}</h1> // 변수 사용
  );
}

// 결과: 홍길동님, 환영합니다!
<Greeting name="홍길동" />
```

4. JSX 속성(Props)과 스타일링
HTML 속성과 거의 같지만, 몇 가지 차이점이 있습니다.

가. `class` 대신 `className`
JavaScript에서 `class`는 예약어이므로, JSX에서는 `className`을 사용합니다.
```jsx
<div className="container">이것은 컨테이너입니다.</div>
```

나. 카멜 케이스(camelCase) 사용
`onclick`이나 `tabindex` 같은 속성들은 카멜 케이스로 작성합니다.

`onclick` -> `onClick`
`onchange` -> `onChange`
`tabindex` -> `tabIndex`
```jsx
<button onClick={() => alert('클릭!')}>클릭하세요</button>
```

다. 인라인 스타일은 객체 형태로
스타일은 문자열이 아닌 JavaScript 객체 형태로 전달해야 합니다. 속성명은 카멜 케이스를 따릅니다.
```jsx
// background-color -> backgroundColor
const divStyle = {
  backgroundColor: 'lightblue',
  fontSize: '16px'
};

<div style={divStyle}>스타일이 적용된 div</div>
```

5. 조건부 렌더링
특정 조건에 따라 다른 UI를 보여줄 때는 주로 삼항 연산자나 && (AND) 연산자를 사용합니다.

```jsx
function UserStatus({ isLoggedIn }) {
  return (
    <div>
      {/* 삼항 연산자: A 또는 B를 보여줄 때 */}
      <p>현재 상태: {isLoggedIn ? '로그인됨' : '로그아웃됨'}</p>

      {/* && 연산자: 조건이 참일 때만 보여줄 때 */}
      {isLoggedIn && <button>로그아웃</button>}
    </div>
  );
}
```

6. 배열을 리스트로 렌더링하기 (`map` 함수)
배열의 각 요소를 UI 요소로 변환할 때는 `map` 함수를 사용합니다. 이때 각 요소는 고유한 `key` 속성을 가져야 React가 효율적으로 변경 사항을 추적할 수 있습니다.
```jsx
function ItemList({ items }) {
  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}

const productItems = [
  { id: 1, name: '노트북' },
  { id: 2, name: '마우스' },
];

<ItemList items={productItems} />
```
