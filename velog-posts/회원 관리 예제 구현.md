# 회원 관리 예제 구현

**Published:** Mon, 05 Jan 2026 09:24:00 GMT
**Link:** https://velog.io/@kik328288/%ED%9A%8C%EC%9B%90-%EA%B4%80%EB%A6%AC-%EC%98%88%EC%A0%9C-%EA%B5%AC%ED%98%84

---

<p><img alt="" src="https://velog.velcdn.com/images/kik328288/post/e4c418a9-b489-4d7c-9533-43f467a27e4e/image.png" /></p>
<h2 id="5-회원-도메인과-리포지토리-개발">5. 회원 도메인과 리포지토리 개발</h2>
<hr />
<h3 id="51-도메인-객체-member">5.1 도메인 객체 (Member)</h3>
<hr />
<p>요구사항에 맞춰 ID와 이름을 가진 회원 객체를 생성한다.</p>
<pre><code class="language-java">package hello.hellospring.domain;

public class Member {
    private Long id;   // 시스템이 저장하는 ID
    private String name;

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}</code></pre>
<h3 id="52-리포지토리-인터페이스-memberrepository">5.2 리포지토리 인터페이스 (MemberRepository)</h3>
<hr />
<p>구현체를 갈아끼울 수 있도록 필수 기능(저장, 조회)을 인터페이스로 정의한다.</p>
<pre><code class="language-java">package hello.hellospring.repository;
import hello.hellospring.domain.Member;
import java.util.List;
import java.util.Optional;

public interface MemberRepository {
    Member save(Member member); // 회원 저장
    Optional&lt;Member&gt; findById(Long id); // ID로 회원을 찾음 (없을 수 있으므로 Optional)
    Optional&lt;Member&gt; findByName(String name); // 이름으로 회원을 찾음
    List&lt;Member&gt; findAll(); // 모든 회원 리스트 반환
}</code></pre>
<h3 id="53-메모리-리포지토리-구현체-memorymemberrepository">5.3 메모리 리포지토리 구현체 (MemoryMemberRepository)</h3>
<hr />
<p><code>Map</code>을 사용하여 메모리에 데이터를 저장하는 단순한 구현체이다.</p>
<pre><code class="language-java">public class MemoryMemberRepository implements MemberRepository {
    // 실무에서는 동시성 문제로 ConcurrentHashMap 사용 고려 [cite: 191]
    private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;(); 
    // 실무에서는 동시성 문제로 AtomicLong 사용 고려 [cite: 191]
    private static long sequence = 0L; 

    @Override
    public Member save(Member member) {
        member.setId(++sequence); // ID 자동 증가
        store.put(member.getId(), member); // Map에 저장
        return member;
    }

    @Override
    public Optional&lt;Member&gt; findById(Long id) {
        // 결과가 null일 경우를 대비해 Optional.ofNullable 사용 [cite: 202]
        return Optional.ofNullable(store.get(id)); 
    }

    @Override
    public Optional&lt;Member&gt; findByName(String name) {
        return store.values().stream()
                .filter(member -&gt; member.getName().equals(name))
                .findAny();
    }

    @Override
    public List&lt;Member&gt; findAll() {
        return new ArrayList&lt;&gt;(store.values());
    }

    // 테스트 종료 후 데이터를 비우기 위한 메서드
    public void clearStore() {
        store.clear(); 
    }
}</code></pre>
<h2 id="6-테스트-케이스-작성-junit">6. 테스트 케이스 작성 (JUnit)</h2>
<hr />
<p>개발한 코드가 정상적으로 작동하는지 검증하기 위해 작성한다. <code>main</code> 메서드나 컨트롤러로 테스트하는 것은 반복 실행이 어렵고 느리기 때문에 <strong>JUnit</strong>이라는 테스트 프레임워크를 사용한다.</p>
<h3 id="61-테스트의-기본-구조">6.1 테스트의 기본 구조</h3>
<hr />
<ul>
<li><strong>Given-When-Then 패턴:</strong> 뭔가 주어졌을 때(Given), 이것을 실행하면(When), 결과가 이래야 한다(Then)는 구조로 작성하면 명확하다.</li>
<li><strong>독립적 실행:</strong> 테스트는 순서와 관계없이 독립적으로 실행되어야 하므로, 공용 데이터는 매 테스트마다 초기화해야 한다.</li>
</ul>
<h3 id="62-주요-애노테이션">6.2 주요 애노테이션</h3>
<hr />
<ul>
<li><strong><code>@Test</code></strong>: 해당 메서드가 테스트 실행 대상임을 명시한다.</li>
<li><strong><code>@AfterEach</code></strong>: 각 테스트 메서드가 실행된 직후에 호출된다. 주로 DB나 메모리 저장소를 비우는(clear) 용도로 사용하여 다음 테스트에 영향을 주지 않게 한다 .</li>
<li><strong><code>@BeforeEach</code></strong>: 각 테스트 메서드 실행 전에 호출된다. 테스트 간의 영향이 없도록 항상 새로운 객체를 생성하고 의존관계를 맺어줄 때 사용한다.</li>
</ul>
<h3 id="63-리포지토리-테스트-예지-memorymemberrepositorytest">6.3 리포지토리 테스트 예지 (MemoryMemberRepositoryTest)</h3>
<hr />
<pre><code class="language-java">class MemoryMemberRepositoryTest {
    MemoryMemberRepository repository = new MemoryMemberRepository();

    @AfterEach
    public void afterEach() {
        repository.clearStore(); // 테스트 끝날 때마다 저장소 비우기 [cite: 236]
    }

    @Test
    public void save() {
        // given
        Member member = new Member();
        member.setName(&quot;spring&quot;);

        // when
        repository.save(member);

        // then
        Member result = repository.findById(member.getId()).get();
        // org.assertj.core.api.Assertions 사용
        assertThat(result).isEqualTo(member); 
    }
}</code></pre>
<h2 id="7-회원-서비스-개발-및-di-의존-관계-주입">7. 회원 서비스 개발 및 DI (의존 관계 주입)</h2>
<hr />
<h3 id="71-비즈니스-로직-구현-memberservice">7.1 비즈니스 로직 구현 (MemberService)</h3>
<hr />
<p>서비스 계층은 '회원 가입', '전체 회원 조회'와 같이 비즈니스에 가까운 용어를 사용한다.</p>
<ul>
<li><strong>중복 회원 검증:</strong> 같은 이름이 있는 회원은 가입할 수 없다는 로직을 추가한다. <code>findByName</code>의 결과가 <code>Optional</code>이므로 <code>ifPresent</code>를 사용하여 로직을 깔끔하게 처리한다 .</li>
</ul>
<pre><code class="language-java">public class MemberService {
    private final MemberRepository memberRepository;

    // 외부에서 리포지토리를 주입받도록 생성자 작성 (DI: Dependency Injection)
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    /**
     * 회원 가입
     */
    public Long join(Member member) {
        validateDuplicateMember(member); // 중복 회원 검증
        memberRepository.save(member);
        return member.getId();
    }

    private void validateDuplicateMember(Member member) {
        memberRepository.findByName(member.getName())
            .ifPresent(m -&gt; {
                throw new IllegalStateException(&quot;이미 존재하는 회원입니다.&quot;);
            });
    }
}</code></pre>
<h3 id="72-서비스-테스트와-di-memberservicetest">7.2 서비스 테스트와 DI (MemberServiceTest)</h3>
<hr />
<p>서비스 테스트 시, 서비스가 사용하는 리포지토리와 테스트에서 확인용으로 쓰는 리포지토리가 서로 다른 인스턴스(<code>new</code>)라면 데이터 불일치 문제가 발생할 수 있다. 이를 해결하기 위해 <strong>DI(Dependency Injection)</strong> 구조를 활용한다.</p>
<pre><code class="language-java">class MemberServiceTest {
    MemberService memberService;
    MemoryMemberRepository memberRepository;

    @BeforeEach
    public void beforeEach() {
        // 테스트 실행 전, 같은 리포지토리를 서비스에 주입해준다 [cite: 342]
        memberRepository = new MemoryMemberRepository();
        memberService = new MemberService(memberRepository);
    }

    @AfterEach
    public void afterEach() {
        memberRepository.clearStore();
    }

    @Test
    public void 중복_회원_예외() {
        // given
        Member member1 = new Member();
        member1.setName(&quot;spring&quot;);

        Member member2 = new Member();
        member2.setName(&quot;spring&quot;); // 중복된 이름

        // when
        memberService.join(member1);

        // then: member2를 join하면 IllegalStateException이 터져야 함
        IllegalStateException e = assertThrows(IllegalStateException.class, 
            () -&gt; memberService.join(member2));

        assertThat(e.getMessage()).isEqualTo(&quot;이미 존재하는 회원입니다.&quot;);
    }
}</code></pre>
<h2 id="9-회원-관리-예제---웹-mvc-개발">9. 회원 관리 예제 - 웹 MVC 개발</h2>
<hr />
<p>스프링 MVC 구조를 활용하여 실제로 <strong>회원 가입(등록)</strong>과 <strong>회원 목록 조회</strong> 기능을 구현한다.</p>
<h3 id="9-1-홈-화면-추가">9-1. 홈 화면 추가</h3>
<hr />
<p>가장 먼저 진입하게 될 대문(Home) 화면을 만든다.</p>
<p><strong>#### 9-1-1. 정적 컨텐츠 vs 컨트롤러 우선순위</strong></p>
<ul>
<li><strong>원칙:</strong> 요청이 오면 스프링 컨테이너는 <strong>관련된 컨트롤러</strong>가 있는지 먼저 찾는다.</li>
<li><strong>우선순위:</strong> 컨트롤러가 있으면 해당 컨트롤러를 호출하고, 없으면 정적 리소스(<code>static/index.html</code>)를 찾는다.</li>
<li><strong>결과:</strong> <code>HomeController</code>가 <code>/</code> 경로에 매핑되어 있으므로, <code>static/index.html</code>은 무시되고 템플릿 엔진이 처리한 화면이 나온다.</li>
</ul>
<p><strong>#### 9-1-2. 홈 컨트롤러 구현 (<code>HomeController</code>)</strong></p>
<pre><code class="language-java">package hello.hellospring.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HomeController {
    @GetMapping(&quot;/&quot;) // 도메인 첫 진입점
    public String home() {
        return &quot;home&quot;; // templates/home.html을 찾아 렌더링
    }
}</code></pre>
<p><strong>#### 9-1-3. 회원 관리용 홈 구현</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE HTML&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;div&gt;
        &lt;h1&gt;Hello Spring&lt;/h1&gt;
        &lt;p&gt;회원 기능&lt;/p&gt;
        &lt;p&gt;
            &lt;a 
            &lt;a 
href=&quot;/members/new&quot;&gt;회원 가입&lt;/a&gt;
href=&quot;/members&quot;&gt;회원 목록&lt;/a&gt;
        &lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt; &lt;!-- /container --&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="9-2-회원-웹-기능---등록-post">9-2. 회원 웹 기능 - 등록 (POST)</h3>
<hr />
<p>데이터를 입력받아 서버에 저장하는 과정이다. <strong>GET</strong> 방식으로 폼을 보여주고, <strong>POST</strong> 방식으로 데이터를 전송한다.</p>
<p><strong>#### 9-2-1. 동작 흐름</strong></p>
<ol>
<li><strong>폼 요청 (GET):</strong> 사용자가 '회원 가입' 버튼을 누르면 <code>/members/new</code>로 이동하여 입력 폼(<code>createMemberForm.html</code>)을 보여준다.</li>
<li><strong>데이터 전송 (POST):</strong> 사용자가 이름을 입력하고 '등록'을 누르면 <code>/members/new</code>로 데이터를 전송한다.</li>
<li><strong>데이터 처리:</strong> 컨트롤러가 <code>MemberForm</code> 객체를 통해 데이터를 받아 서비스(<code>MemberService</code>)를 호출하여 저장한다.</li>
<li><strong>리다이렉트:</strong> 저장이 완료되면 홈 화면(<code>/</code>)으로 돌려보낸다.</li>
</ol>
<h4 id="9-2-2-코드-구현">9-2-2. 코드 구현</h4>
<ul>
<li>회원 등록 컨트롤러 (<code>MemberController</code>)</li>
</ul>
<pre><code class="language-java">@Controller
public class MemberController {
    private final MemberService memberService;

    // 생성자 주입
    @Autowired
    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }

    // 1. 등록 폼 화면 조회 (GET)
    @GetMapping(&quot;/members/new&quot;)
    public String createForm() {
        return &quot;members/createMemberForm&quot;;
    }

    // 2. 실제 등록 처리 (POST)
    @PostMapping(&quot;/members/new&quot;)
    public String create(MemberForm form) {
        // MemberForm 객체의 setter를 통해 데이터가 들어옴
        Member member = new Member();
        member.setName(form.getName());

        memberService.join(member); // 핵심 비즈니스 로직 호출

        return &quot;redirect:/&quot;; // 홈 화면으로 리다이렉트
    }
}</code></pre>
<ul>
<li><strong>폼 객체 (<code>MemberForm</code>)</strong><ul>
<li>HTML Form 태그의 <code>input</code> 태그 <code>name</code> 속성값과 이 클래스의 필드명이 매칭되어 데이터가 자동으로 들어온다.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class MemberForm {
    private String name; // input name=&quot;name&quot; 과 매칭

    // getter, setter 필요
    public String getName() { 
        return name; 
    }

    public void setName(String name) { 
        this.name = name; 
    }
}</code></pre>
<ul>
<li>회원 등록 폼 HTML (<code>createMemberForm</code>)</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE HTML&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;form action=&quot;/members/new&quot; method=&quot;post&quot;&gt;
        &lt;div 
class=&quot;form-group&quot;&gt;
            &lt;label 
for=&quot;name&quot;&gt;이름&lt;/label&gt;
            &lt;input 
요&quot;&gt;
type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; placeholder=&quot;이름을 입력하세
        &lt;/div&gt;
        &lt;button type=&quot;submit&quot;&gt;등록&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt; &lt;!-- /container --&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="9-3-회원-웹-기능---조회-get">9-3. 회원 웹 기능 - 조회 (GET)</h3>
<hr />
<p>서버에 저장된 모든 회원 데이터를 가져와서 화면에 뿌려주는 과정이다.</p>
<p><strong>#### 9-3-1. 동작 흐름</strong></p>
<ol>
<li><strong>목록 요청 (GET):</strong> 사용자가 '회원 목록'을 클릭하면 <code>/members</code>로 요청을 보낸다.</li>
<li><strong>데이터 조회:</strong> 컨트롤러가 서비스에서 <code>findMembers()</code>를 호출해 모든 회원을 가져온다.</li>
<li><strong>모델 담기:</strong> 조회된 리스트를 <code>Model</code> 객체에 <code>addAttribute(&quot;members&quot;, list)</code>로 담는다.</li>
<li><strong>화면 렌더링:</strong> 뷰(Thymeleaf)에서 모델에 담긴 <code>members</code>를 꺼내 반복문(<code>th:each</code>)을 돌며 표를 그린다.</li>
</ol>
<p><strong>#### 9-3-2. 코드 구현</strong></p>
<ul>
<li>회원 조회 컨트롤러 (<code>MemberController</code>)</li>
</ul>
<pre><code class="language-java">@GetMapping(&quot;/members&quot;)
public String list(Model model) {
    List&lt;Member&gt; members = memberService.findMembers();
    model.addAttribute(&quot;members&quot;, members); // 뷰에 데이터를 넘길 때 Model 사용
    return &quot;members/memberList&quot;;
}</code></pre>
<ul>
<li><strong>회원 목록 뷰 템플릿 (<code>memberList.html</code>)</strong><ul>
<li>Thymeleaf 문법인 <code>th:each</code>를 사용하여 루프를 실행한다.</li>
</ul>
</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE HTML&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;div&gt;
        &lt;table&gt;
            &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;#&lt;/th&gt;
                &lt;th&gt;이름&lt;/th&gt;
            &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                          &lt;tr th:each=&quot;member : ${members}&quot;&gt;
                        &lt;td th:text=&quot;${member.id}&quot;&gt;&lt;/td&gt;   &lt;td th:text=&quot;${member.name}&quot;&gt;&lt;/td&gt; &lt;/tr&gt;
                        &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/div&gt; &lt;!-- /container --&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4 id="9-3-3-참고">9-3-3. 참고</h4>
<ul>
<li><strong>컨트롤러 우선:</strong> 정적 파일보다 컨트롤러 매핑이 우선순위를 가진다.</li>
<li><strong>데이터 전달 (Client -&gt; Server):</strong> HTML Form 태그(<code>name</code> 속성) → 컨트롤러 파라미터(객체)로 데이터가 전달될 때 스프링이 자동으로 값을 채워준다 (프로퍼티 접근 방식, Setter).</li>
<li><strong>데이터 전달 (Server -&gt; Client):</strong> <code>Model</code> 객체에 데이터를 담아 뷰 템플릿으로 넘겨주면, 템플릿 엔진이 이를 동적으로 렌더링한다.</li>
</ul>