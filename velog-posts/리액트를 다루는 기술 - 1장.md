# 리액트를 다루는 기술 - 1장

**Published:** Fri, 26 Sep 2025 05:22:16 GMT
**Link:** https://velog.io/@kik328288/%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%A5%BC-%EB%8B%A4%EB%A3%A8%EB%8A%94-%EA%B8%B0%EC%88%A0-1%EC%9E%A5

---

<h2 id="1장-리액트-시작">1장 리액트 시작</h2>
<h3 id="11-왜-리액트인가">1.1 왜 리액트인가?</h3>
<ol>
<li>자바스크립트 인식 변화</li>
</ol>
<ul>
<li>과거 : 웹 브라우저에서 간단한 연산을 하거나 시각적인 효과를 주는 단순한 스크립트 언어</li>
<li>현재 : 웹 애플리케이션에서 가장 핵심적인 역할</li>
</ul>
<ol start="2">
<li>자바스크립트 기반 프레임워크
<img alt="" src="https://velog.velcdn.com/images/kik328288/post/9b4d4e46-9407-4d7e-ae25-d6f72bd7cb93/image.png" /></li>
</ol>
<ul>
<li><p>해당 프레임워크들은 주로 MVC(Model-View-Controller) 아키텍처, MVVM(Model-View-View Model) 아키텍처 사용</p>
</li>
<li><p>AngularJS의 경우 MVW(Model-View-Whatever) 아키텍처로 애플리케이션 구조화</p>
</li>
<li><p>MVC, MVVM, MVW 등 여러 구조가 지닌 공통점 : 모델(Model), 뷰(View) 보유</p>
<ul>
<li>모델(Model) : 애플리케이션에서 사용하는 데이터를 관리하는 영역</li>
<li>뷰(View) : 사용자에게 보이는 부분</li>
<li>프로그램이 사용자에게서 어떤 작업을 받으면 컨트롤러는 모델 데이터를 조회하거나 수정하고, 변경된 사항을 뷰에 반영
<img alt="" src="https://velog.velcdn.com/images/kik328288/post/de04fa15-cfbd-4057-88d0-ab46c942feb4/image.png" /></li>
<li>반영하는 과정에서 보통 뷰를 변형</li>
</ul>
</li>
<li><p>업데이트하는 항목에 따라 어떤 부분을 찾아서 변경할 지 규칙을 정하는 작업은 간단하지만, 애플리케이션 규모가 크면 상당히 복잡해지고 제대로 관리하지 않으면 성능 감소 가능성 존재</p>
<ul>
<li>어떤 데이터가 변할 때마다 어떤 변화를 줄 지 고민하는 것이 아니라 그냥 기존 뷰를 날려버리고 처음부터 새로 렌더링하는 방식으로 해결<ul>
<li>애플리케이션 구조가 매우 간단해짐</li>
<li>작성해야 할 코드의 양 역시 감소</li>
<li>더 이상 어떻게 변화를 줄 지 신경 쓸 필요 없음</li>
<li>뷰가 어떻게 생길 지 선언하며, 데이터에 변화가 있음녀 기존에 있던 것을 버리고 정해진 규칙에 따라 새로 렌더링하면 해결됨</li>
</ul>
</li>
</ul>
</li>
<li><p>이러한 것들을 해결하고 동작하는 것이 바로 리액트(React)</p>
</li>
</ul>
<hr />
<h4 id="111-리액트-이해">1.1.1 리액트 이해</h4>
<ul>
<li>리액트(React)<ul>
<li>자바스크립트 라이브러리</li>
<li>사용자 인터페이스를 만드는 데 사용되는 프레임워크</li>
<li>구조가 MVC, MVW 등인 프레임워크와 달리 오직 V(View)만 신경 쓰는 라이브러리</li>
</ul>
</li>
<li>컴포넌트(Component)<ul>
<li>React 프로젝트에서 특정 부분이 어떻게 생길지 정하는 선언체</li>
<li>다른 프레임워크에서 사용자 인터페이스를 다룰 때 사용하는 템플릿과는 다른 개념</li>
<li>재사용이 가능한 API =&gt; 수많은 기능들을 내장</li>
<li>컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식 정의</li>
<li>컴포넌트 내부에는 또 다른 컴포넌트가 들어가는 것 가능</li>
</ul>
</li>
<li>템플릿<ul>
<li>데이터셋이 주어지면 HTML 태그 형식을 문자열로 반환</li>
</ul>
</li>
<li>렌더링<ul>
<li>사용자 화면에 뷰를 보여주는 것<h5 id="1111-초기-렌더링">1.1.1.1 초기 렌더링</h5>
어떤 UI 관련 프레임워크, 라이브러리를 사용하든지 간에 맨 처음 어떻게 보일 지를 정하는 초기 렌더링 필요</li>
</ul>
</li>
<li>render() 함수<ul>
<li>사용 형식 : render() { ... }</li>
<li>컴포넌트가 어떻게 생겼는 지 정의하는 역할</li>
<li>html 형식의 문자열을 반환하지 않고, 뷰가 어떻게 생겼고 어떻게 작동하는 지에 대한 정보를 지닌 객체 반환</li>
<li>render 함수를 실행하면 그 내부에 있는 컴포넌트들도 재귀적으로 렌더링</li>
</ul>
</li>
<li>최상위 컴포넌트의 렌더링 작업이 끝나면 지니고 있는 정보들을 사용해 HTML 마크업을 만들고, 이를 우리가 정하는 실제 페이지의 DOM 요소 안에 주입
<img alt="" src="https://velog.velcdn.com/images/kik328288/post/ff9f5f57-4546-4f79-87e5-a30c1e03bfbf/image.png" /></li>
<li>컴포넌트를 실제 페이지에 렌더링할 때는 분리된 두 가지 절차를 따름<ol>
<li>문자열 형태의 HTML 코드 생성</li>
<li>특정 DOM에 해당 내용을 주입</li>
<li>이벤트 적용<h5 id="1112-조화-과정">1.1.1.2 조화 과정</h5>
render 함수의 추가적인 역할</li>
</ol>
</li>
<li>뷰가 어떻게 생겼고 어떻게 작동하는 지에 대한 정보를 지닌 객체 반환</li>
<li>컴포넌트는 데이터를 업데이트했을 때 단순히 업데이트한 값을 수정하는 것이 아니라, 새로운 데이터를 가지고 render 함수를 다시 호출하는 것</li>
<li>render 함수가 반환하는 결과를 바로 DOM에 반영하지 않고 이전에 render 함수가 만들었던 컴포넌트 정보와 현재 render 함수가 만든 컴포넌트 정보 비교
<img alt="" src="https://velog.velcdn.com/images/kik328288/post/bc925a1f-d494-415b-bcd6-482e63af9fa8/image.png" /></li>
<li>자바스크립트를 사용해 두 가지 뷰를 최소한의 연산으로 비교한 후, 둘의 차이를 알아내 최소한의 연산으로 DOM 트리를 업데이트 하는 것
<img alt="" src="https://velog.velcdn.com/images/kik328288/post/e4afb053-6450-4b41-950a-d120aae63377/image.png" /></li>
<li>결론 : 방식 자체는 루트 노드부터 시작하여 전체 컴포넌트를 처음부터 다시 렌더링하는 것처럼 보이지만, 최적의 자원을 사용해 이를 수행하는 것</li>
</ul>
<hr />
<h3 id="12-리액트의-특징">1.2 리액트의 특징</h3>
<h4 id="121-virtual-dom">1.2.1 Virtual DOM</h4>
<p>리액트의 주요 특징 중 하나 : Virtual DOM 사용</p>
<h5 id="1211-dom이란">1.2.1.1 DOM이란?</h5>
<ul>
<li><p>DOM (Document Object Model)</p>
<ul>
<li>XML, HTML 등을 이용해 객체로 문서 구조를 표현하는 방법</li>
<li>트리 형태이기 때문에 특정 노드를 찾거나 수정하거나 제거하거나 원하는 곳에 삽입 가능
<img alt="" src="https://velog.velcdn.com/images/kik328288/post/e5a93604-ce89-42e7-b96b-c27f860a0ab0/image.png" /></li>
</ul>
</li>
<li><p>DOM의 속도</p>
<ul>
<li>DOM API를 수많은 플랫폼과 웹 브라우저에서 사용 중</li>
<li>DOM의 문제점<ul>
<li>동적 UI에 최적화되어 있지 않다는 것</li>
<li>HTML이 자체적으로 정적이지만 자바스크립트를 사용해 동적으로 만들 수 있기 때문</li>
</ul>
</li>
<li>규모가 큰 웹 애플리케이션에서 DOM에 직접 접근하여 변화를 주게 될 경우 성능 이슈가 조금 발생해 속도가 느려짐</li>
<li>DOM 자체의 속도는 빠른 편<ul>
<li>DOM 자체를 읽고 쓸 때의 성능은 자바스크립트 객체를 처리할 때의 성능과 비교해 별 차이가 없음</li>
<li>웹 브라우저 단에서 DOM에 변화가 일어날 경우 웹 브라우저가 CSS를 다시 연산하고, 레이아웃을 구성하고, 페이지를 리페인트하기 때문에 시간이 더 걸리는 것</li>
</ul>
</li>
</ul>
</li>
<li><p>DOM의 속도 저하 문제 해결 방법 : 리액트에서 Virtual DOM 방식을 활용해 DOM 업데이트를 추상화함으로써 DOM 처리 횟수를 최소화하고 효율적으로 진행</p>
<h5 id="1212-virtual-dom">1.2.1.2 Virtual DOM</h5>
<p>Virtual DOM 사용할 경우 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용
실제 DOM의 가벼운 사본과 비슷하다고 생각하면 됨
리액트에서데이터가 변하여 웹 브라우저에 실제 DOM을 업데이트 할 때 절차</p>
</li>
</ul>
<ol>
<li>데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링</li>
<li>이전 Virtual DOM에 있던 내용과 현재 내용 비교</li>
<li>바뀐 부분만 실제 DOM에 적용
<img alt="" src="https://velog.velcdn.com/images/kik328288/post/bc925a1f-d494-415b-bcd6-482e63af9fa8/image.png" /></li>
</ol>
<ul>
<li>리액트와 Virtual DOM이 언제나 제공할 수 있는 것 : 업데이트 처리 간결성<ul>
<li>UI를 업데이트하는 과정에서 생기는 복잡함을 모두 해소</li>
<li>더욱 쉽게 업데이트에 접근 가능<h4 id="122-기타-특징">1.2.2 기타 특징</h4>
</li>
</ul>
</li>
<li>리액트의 경우 MVC 또는 MVW 등의 구조를 지향하는 것과 달리 오직 뷰만 담당</li>
<li>리액트는 프레임워크가 아니라 라이브러리이므로 기타 기능은 직접 구현하여 사용해야 함</li>
<li>라우팅에는 react-router, Ajax 처리에는 axios나 fetch, 상태 관리에는 redix나 MobX를 사용</li>
<li>해당 분야에서 마음에 드는 라이브러리를 사용하면 되서 자신의 취향대로 스택을 설정할 수 있다는 장점</li>
<li>여러 라이브러리를 접해야 한다는 단점
<img alt="" src="https://velog.velcdn.com/images/kik328288/post/ff0beda5-53ad-4da4-bd59-586b8209a843/image.png" /></li>
<li>리액트는 다른 웹 프레임워크나 라이브러리와 혼용 가능
<img alt="" src="https://velog.velcdn.com/images/kik328288/post/c0653a77-1f30-43bc-b773-76b00cb17626/image.png" /><h3 id="13-react-프로젝트-생성">1.3 React 프로젝트 생성</h3>
<h4 id="131-🚀-cra-create-react-app-정말-지원-중단됐을까-feat-앞으로의-react-프로젝트-설정">1.3.1 🚀 CRA (Create React App) 정말 지원 중단됐을까? (feat. 앞으로의 React 프로젝트 설정)</h4>
</li>
</ul>
<p>안녕하세요! React를 처음 배울 때 가장 먼저 만나는 친구 같은 존재, <code>create-react-app</code>에 대한 이야기를 해보려고 합니다. 최근 CRA가 지원 중단되었다, 혹은 deprecated 되었다는 이야기를 많이 들어보셨을 텐데요. 그런데 막상 터미널에 <code>npx create-react-app my-app</code>을 입력하면 아무 문제 없이 프로젝트가 생성되는 것을 보고 혼란스러우셨을 겁니다.</p>
<p>결론부터 말씀드리면, <strong>CRA는 공식적으로 새로운 기능 업데이트가 중단된 것이 맞지만, 완전히 사용 불가능한 상태는 아닙니다.</strong> 이 글에서는 CRA의 현재 상태는 어떤지, 왜 여전히 작동하는지, 그리고 앞으로 우리는 어떤 도구를 사용해야 할지에 대해 자세히 알아보겠습니다.</p>
<h5 id="1311-cra-정확히-어떤-상태인가요">1.3.1.1 CRA, 정확히 어떤 상태인가요?</h5>
<p>React 공식 문서(react.dev)의 <a href="https://react.dev/learn/start-a-new-react-project">Start a New React Project</a> 페이지에 방문하면 더 이상 CRA를 기본 도구로 추천하지 않는 것을 확인할 수 있습니다.</p>
<blockquote>
<p><strong>&quot;If you’re looking to create a new app or a new site with React, we recommend picking one of the production-grade React frameworks.&quot;</strong>
(React로 새로운 앱이나 사이트를 만들고 싶다면, 프로덕션 등급의 React 프레임워크 중 하나를 선택하는 것을 추천합니다.)</p>
</blockquote>
<p>과거에는 CRA가 React 학습의 표준 시작점이었지만, 지금은 <strong>Next.js, Remix, Gatsby</strong> 같은 프레임워크나 <strong>Vite, Parcel</strong>과 같은 차세대 빌드 도구를 권장하고 있습니다.</p>
<p>CRA의 GitHub 저장소를 보아도 2023년 이후로는 큰 업데이트가 거의 없는 '유지보수 모드(maintenance mode)'에 가깝습니다. 이는 새로운 기능 추가나 대대적인 개선은 없지만, 심각한 보안 취약점이 발견되면 패치를 제공하는 수준이라고 이해할 수 있습니다.</p>
<h5 id="1312-그런데-왜-여전히-작동할까요">1.3.1.2 그런데 왜 여전히 작동할까요?</h5>
<p>CRA가 지원 중단되었다고 해서 npm 레지스트리에서 패키지가 삭제되는 것은 아닙니다. <code>npx create-react-app</code> 명령어는 여전히 npm에 등록된 마지막 버전의 CRA 패키지를 다운로드하여 프로젝트를 생성합니다. 따라서 기존 방식대로 프로젝트를 만드는 것 자체는 가능합니다.</p>
<p>하지만 여기에는 몇 가지 문제점이 있습니다.</p>
<ul>
<li><strong>느린 개발 서버 속도</strong>: CRA는 내부적으로 Webpack을 사용합니다. Vite와 같은 최신 번들러는 ESBuild를 사용하여 훨씬 빠른 개발 서버 구동 속도와 Hot Module Replacement(HMR) 성능을 보여줍니다. 프로젝트 규모가 커질수록 이 차이는 크게 체감됩니다.</li>
<li><strong>오래된 의존성</strong>: 핵심 라이브러리들의 업데이트가 중단되어 최신 버전의 이점을 누리기 어렵고, 잠재적인 보안 위협에 노출될 수 있습니다.</li>
<li><strong>확장성의 한계</strong>: Babel, Webpack 설정을 직접 수정하려면 <code>eject</code> 명령어를 사용해야 하는데, 한번 실행하면 되돌릴 수 없고 모든 설정의 책임이 개발자에게 넘어와 복잡성이 크게 증가합니다.</li>
</ul>
<h5 id="1313-이제-우리는-무엇을-사용해야-할까요">1.3.1.3 이제 우리는 무엇을 사용해야 할까요?</h5>
<p>React 팀과 커뮤니티가 추천하는 현대적인 대안은 다음과 같습니다.</p>
<p> ✅ <strong>Vite: 가장 유력한 CRA 대체재</strong></p>
<p><img alt="" src="https://velog.velcdn.com/images/kik328288/post/a6f1832b-b392-4f71-a911-557acf0b0f6f/image.png" />
 만약 순수 React SPA(Single Page Application)를 만들고 싶고, CRA의 경험과 가장 유사하면서도 강력한 성능을 원한다면 <strong>Vite</strong>가 최고의 선택입니다.</p>
<ul>
<li><strong>압도적으로 빠른 속도</strong>: ESBuild를 사용한 빠른 개발 서버와 빌드 속도를 자랑합니다.</li>
<li><strong>간단한 설정</strong>: CRA만큼이나 시작이 쉽고, 필요한 경우 <code>vite.config.js</code> 파일을 통해 손쉽게 설정을 확장할 수 있습니다.</li>
<li><strong>활발한 생태계</strong>: 수많은 플러그인과 커뮤니티 지원을 통해 개발 경험을 향상시킬 수 있습니다.</li>
</ul>
<p><strong>Vite로 React 프로젝트 시작하기:</strong></p>
<pre><code class="language-bash"># npm
npm create vite@latest my-react-app -- --template react

# yarn
yarn create vite my-react-app --template react

# pnpm
pnpm create vite my-react-app --template react</code></pre>
<p><img alt="" src="https://velog.velcdn.com/images/kik328288/post/bc60fc82-0096-4efb-9046-c588fb1ffe55/image.png" /></p>
<hr />